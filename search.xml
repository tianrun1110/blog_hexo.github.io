<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树</title>
    <url>/%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content><![CDATA[<p>三种遍历方式  </p><ol>
<li>前序遍历：先输出父节点，再遍历左子树和右子树</li>
<li>中序遍历：先输出左子树，再输出父节点，再输出右子树</li>
<li>后序遍历：先输出左子树，在输出右子树，再输出父节点  </li>
</ol><p>树的示意图  </p><p><dev style="
    float: left;
    width: 50%;
"><img src="/images/pasted-4.png"></dev><dev style="
    float: right;
    height: 300px;
    font-size: small;
    width: 48%;
">树的常用术语：<br>1.节点<br>2.根节点<br>3.父节点<br>4.子节点<br>5.叶子节点（没有子节点）<br>6.节点的权（节点值）<br>7.路径（从root找到该节点的路线）<br>8.层<br>9.子树<br>10.树的高度（最大层数）<br>11.森林：多棵子树构成森林<br></dev><div style="clear:both;"><br>二叉树的概念  </div></p><a id="more"></a>



<ol>
<li>每个节点最多只能有两个子节点的树称为二叉树</li>
<li>二叉树的子节点分为左子节点和右子节点</li>
<li>如果该二叉树的所有叶子节点都在最后一层，并且节点总数为2^n-1，n为层数，则我们称为满二叉树</li>
<li>如果该二叉树的所有叶子节点都在最后一层或是倒数第二层，而且最后一层的叶子节点在左面连续，倒数第二层的叶子节点在右边连续，则称为完全二叉树</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>线索二叉树</title>
    <url>/%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content><![CDATA[<p>将数列{1 , 3 , 6 , 8 , 10 , 14}构建成一个二叉树.</p><p><code>如下图所示</code><br><img src="/images/pasted-2.png" heigth="400" width="300"><br><code>问题分析：</code></p><ol>
<li>对上面的二叉树进行中序遍历：{8 , 3 , 10 , 1 , 6 , 14}</li>
<li>但是6，8，10，14 这个几个节点的左右指针并没有完全利用上</li>
<li>如果我们希望能够利用个个节点的左右指针，让个个节点指向自己的前后节点怎么办？</li>
</ol><a id="more"></a>


<p>解决方案：线索化二叉树</p>
<h5 id="线索化二叉树的基本介绍"><a href="#线索化二叉树的基本介绍" class="headerlink" title="线索化二叉树的基本介绍"></a>线索化二叉树的基本介绍</h5><ol>
<li>n个节点的二叉链表中含有n+1 公式2n-(n-1)=n+1个空指针域。利用二叉链表中的空指针域，存放指向该节点在<code>某种遍历次序</code>下前驱和后继节点的指针（这种附加的指针称为“线索”）</li>
<li>这种加了线索的二叉链表叫线索链表，相应的二叉树称为<code>线索二叉树（threaded binarytree）</code>。根据线索的性质不同，线索二叉树可分为<code>前序线索二叉树</code>，<code>中序线索二叉树</code>，<code>后序线索二叉树</code>三种。</li>
<li>一个节点的前一个节点 称为<code>前驱</code>节点。</li>
<li>一个节点的后一个节点 称为<code>后继</code>节点。</li>
</ol>
<p><code>图解思路</code>(中序遍历)</p>
<p><img src="/images/pasted-3.png" alt="upload successful"></p>
<p><strong>说明：当线索化二叉树后，Node节点的属性left和right</strong>，有如下情况：  </p>
<ul>
<li>left指向的是左子树，也可能是指向的前驱节点，比如①节点left指向的左子树，而⑩节点的left指向的就是前驱节点.  </li>
<li>right指向的是右子树，也可能是指向后继节点，比如①节点right指向的是右子树，而⑩节点的right指向的是后继节点.</li>
</ul>
<h5 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h5><p><strong>说明</strong>：对前面的中序线索化的二又树，进行遍历<br><strong>分析</strong>：因为线索化后，各个结点指向有变化，因此<strong>原来的遍历方式不能使用</strong>，这时需要使用新的方式遍历线索化二叉树，各个节点可以通过线型方式遍历，因此无需使用递归方式，这样也提高了遍历的效率。<strong>遍历的次序应当和中序遍历保持一致</strong>。</p>
<h5 id="↘️代码实现"><a href="#↘️代码实现" class="headerlink" title="↘️代码实现"></a>↘️代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> erchashu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.HttpRetryException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode root = <span class="keyword">new</span> HeroNode(<span class="number">1</span>,<span class="string">"tom"</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>,<span class="string">"jack"</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>,<span class="string">"smith"</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">"mary"</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>,<span class="string">"king"</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>,<span class="string">"dim"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建二叉树</span></span><br><span class="line">        root.setLeft(node2);</span><br><span class="line">        root.setRight(node3);</span><br><span class="line">        node2.setLeft(node4);</span><br><span class="line">        node2.setRight(node5);</span><br><span class="line">        node3.setLeft(node6);</span><br><span class="line">        <span class="comment">//测试线索化</span></span><br><span class="line">        ThreadedBinaryTree threadedBinaryTree = <span class="keyword">new</span> ThreadedBinaryTree();</span><br><span class="line">        threadedBinaryTree.setRoot(root);</span><br><span class="line">        threadedBinaryTree.threadedNodes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        HeroNode leftNode = node5.getLeft();</span><br><span class="line">        HeroNode rightNode = node5.getRight();</span><br><span class="line">        System.out.println(<span class="string">"10号节点的前驱节点是："</span> + leftNode); </span><br><span class="line">        System.out.println(<span class="string">"10号节点的后继节点是："</span> + rightNode); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当线索化二叉树后，不能再使用原来的遍历方法</span></span><br><span class="line">        <span class="comment">// threadedBinaryTree.infixOrder();</span></span><br><span class="line">        System.out.println(<span class="string">"使用线索化的方法遍历线索化二叉树"</span>);</span><br><span class="line">        threadedBinaryTree.threadedList();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现线索功能的二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line">    <span class="comment">// 在递归进行线索化时，pre总是保留前一个结点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载threadedNodes</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Method</span>_Name:threadedList</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 中序遍历线索化二叉树的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 循环的找到leftType==1的结点，第一个找到就是8结点</span></span><br><span class="line">            <span class="comment">// 后面随着遍历而变化，因为当leftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">// 处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 打印当前节点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">// 如果当前节点的右指针指向的是后继结点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取当前节点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Method</span>_Name:threadedNodes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span>: 编写中序线索化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node void 当前需要线索化的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">threadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果node==null不能线索化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// （一）先线素化左子树</span></span><br><span class="line">        threadedNodes(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （二）线索化当前结点</span></span><br><span class="line">        <span class="comment">// 处理当前节点的前驱结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 让当前节点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">// 修改当前接地点左指针的类型，指向前驱结点</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 让前驱结点的右指针指向当前节点</span></span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            <span class="comment">// 修改前驱结点的右指针类型</span></span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每处理一个结点后，让当前节点是下一个节点的前驱结点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （三）在线索化右子树</span></span><br><span class="line">        threadedNodes(node.getRight());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建HerNode结点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;<span class="comment">// 默认为空</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode right;<span class="comment">// 默认为空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果leftType==0表示指向左子树，如果是1表示指向前驱结点</span></span><br><span class="line">    <span class="comment">// 如果rightType==0表示指向右子树，如果是1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HeroNode [no="</span> + no + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序存储二叉树</title>
    <url>/%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content><![CDATA[<p>数组和树可以相互转换</p><p><code>如下图所示</code></p><img src="/images/pasted-1.png" width="300" height="200" alt="图片名称" align="center"><ol>
<li>二叉树的节点，以数组的方式来存放 arr : [1,2,3,4,5,6,7]</li>
<li>要求在遍历数组时，仍然可以以前序、中序、后序遍历的方式完成节点的遍历</li>
</ol><h4 id="顺序二叉树的特点："><a href="#顺序二叉树的特点：" class="headerlink" title="顺序二叉树的特点："></a>顺序二叉树的特点：</h4><ol>
<li>顺序二叉树通常只考虑完全二叉树。</li>
<li>第n个元素的左子节点在数组的下标为：2*n+1</li>
<li>第n个元素的右子节点在数组的下标为：2*n+2</li>
<li>第n个元素的父节点为：（n-1）/2</li>
<li>n表示的是二叉树的第几个元素，编号从0开始。</li>
</ol><a id="more"></a>





<h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> erchashu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> ArrayBinaryTree(arr).preOrder(); <span class="comment">//运行结果为 1 2 4 5 3 6 7</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree,实现顺序存储二叉遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayBinaryTree</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;<span class="comment">//存数据节点的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空 ， 或arr.length = 0</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"数组为空，不能按照二叉树的前序遍历"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//输出当前元素</span></span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">1</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span>((index * <span class="number">2</span> + <span class="number">2</span>) &lt; arr.length)&#123;</span><br><span class="line">            preOrder(index * <span class="number">2</span> + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这种树的结构会在堆排序种使用。</li>
</ul>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal的作用及使用</title>
    <url>/ThreadLocal%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BD%BF%E7%94%A8.html</url>
    <content><![CDATA[<p><mark>ThreadLocal不是用来解决共享对象的多线程访问问题的</mark>，通过ThreadLocal的set()方法设置到线程ThreadLocal.ThreadLocalMap里的是线程自己要存储的对象。其他的线程是不需要访问的，也不能进行访问。各个线程中的ThreadLocal.ThreadLocalMap以及ThreadLocal.ThreadLocal中的值都是不同的对象。  </p><a id="more"></a>
<h5 id="threadLocal的简单使用："><a href="#threadLocal的简单使用：" class="headerlink" title="threadLocal的简单使用："></a>threadLocal的简单使用：</h5><p>首先ThreadLocal肯定是全局共享的：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tools</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; t1 = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写一个线程往线程里面塞值：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger ai = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadLocalThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">                Tools.t1.set(ai.addAndGet(<span class="number">1</span>) +<span class="string">""</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.getName() + <span class="string">"get----value------&gt;"</span> + Tools.t1.get());</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocalThread threadLocalThread = <span class="keyword">new</span> ThreadLocalThread(<span class="string">"Thread1"</span>);</span><br><span class="line">        ThreadLocalThread threadLocalThread1 = <span class="keyword">new</span> ThreadLocalThread(<span class="string">"Thread2"</span>);</span><br><span class="line">        ThreadLocalThread threadLocalThread2 = <span class="keyword">new</span> ThreadLocalThread(<span class="string">"Thread3"</span>);</span><br><span class="line">        threadLocalThread.start();</span><br><span class="line">        threadLocalThread1.start();</span><br><span class="line">        threadLocalThread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread1get----value------&gt;<span class="number">1</span></span><br><span class="line">Thread2get----value------&gt;<span class="number">2</span></span><br><span class="line">Thread3get----value------&gt;<span class="number">3</span></span><br><span class="line">Thread1get----value------&gt;<span class="number">5</span></span><br><span class="line">Thread3get----value------&gt;<span class="number">6</span></span><br><span class="line">Thread2get----value------&gt;<span class="number">4</span></span><br><span class="line">Thread1get----value------&gt;<span class="number">7</span></span><br><span class="line">Thread2get----value------&gt;<span class="number">9</span></span><br><span class="line">Thread3get----value------&gt;<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>看到每个线程的里都有自己的String，并且互不影响—-因为绝对不可能出现数字重复的情况。用一个ThreadLocal也可以多次set一个数据，set仅仅表示的是线程的ThreadLocal.ThreadLocalMap中table的某一位置的value被覆盖成你最新设置的那个数据而已，<mark>对于同一个ThreadLocal对象而言，set后，table中绝不会多出一个数据。</mark>  </p>
<h5 id="ThreadLocal总结"><a href="#ThreadLocal总结" class="headerlink" title="ThreadLocal总结"></a>ThreadLocal总结</h5><ol>
<li><mark>ThreadLocal不是集合</mark>，它不存储任何内容，真正存储数据的集合在Thread中。<mark>ThreadLocal只是一个工具，一个往各个线程的ThreadLocal.ThreadLocalMap中table的某一位置set一个值的工具而已</mark>  </li>
<li>同步与ThreadLocal是解决多线程中数据访问问题的两种思路，<mark>前者是数据共享的思路，后者是数据隔离的思路</mark>  </li>
<li>同步是一种以时间换空间的思想，ThreadLocal是一种空间换时间的思想  </li>
<li>ThreadLocal既然是与线程相关的，那么对于Java Web来讲，ThreadLocal设置的值只在一次请求中有效，是不是和request很像？因为request里面的内容也只在一次请求有效，<br>对比一下二者的区别：<ol>
<li>ThreadLocal只能存一个值，一个Request由于是Map形式的，可以用key-value形式存多个值</li>
<li>ThreadLocal一般用在框架，Request一般用在表示层、Action、Servlet</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>四种mysql的存储引擎</title>
    <url>/%E5%9B%9B%E7%A7%8Dmysql%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据库引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。使用不同的存储引擎还能获得特定的功能。现在许多不同的数据库管理系统都支持不同的数据引擎。MySQL的核心就是存储引擎。</p><h1 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h1><a id="more"></a>
<p>mysql给开发者提供了 查询存储引擎的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show ENGINES;</span><br></pre></td></tr></table></figure>
<p>查看结果：(我用的是navicat)</p>
<p><img src="/images/pasted-0.png" alt="upload successful"></p>
<p>看到MySQL给用户提供了这么多的存储引擎。包括处理事务安全表的引擎和处理非事务安全表引擎。</p>
<p>想查看数据库默认使用的是哪个引擎，通过命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show VARIABLES like &apos;storage_engine&apos;;</span><br></pre></td></tr></table></figure>
<p>在MySQL中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。Support列的值表示某种引擎是否能使用：YES表示可以使用、NO表示不能使用、DEFAULT表示该引擎为当前默认的存储引擎 。下面来看一下其中几种常用的引擎。</p>
<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。InnoDB主要特性有：</p>
<ol>
<li>InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合</li>
<li>InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的</li>
<li>InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</li>
<li>InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键</li>
<li>InnoDB被用在众多需要高性能的大型数据库站点上</li>
</ol>
<h2 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h2><p>MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物。MyISAM主要特性有：</p>
<ol>
<li>大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持</li>
<li>当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成</li>
<li>每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16</li>
<li>最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上</li>
<li>BLOB和TEXT列可以被索引</li>
<li>NULL被允许在索引的列中，这个值占每个键的0~1个字节</li>
<li>所有数字键值以高字节优先被存储以允许一个更高的索引压缩</li>
<li>每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快</li>
<li>可以把数据文件和索引文件放在不同目录</li>
<li>每个字符列可以有不同的字符集</li>
<li>有VARCHAR的表可以固定或动态记录长度</li>
<li>VARCHAR和CHAR列可以多达64KB</li>
</ol>
<p>使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 函数汇总</title>
    <url>/mysql-%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB.html</url>
    <content><![CDATA[<div class="note info">
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>MySQL提供了众多的强大的功能，方便易用的函数，使用这些函数，可以极大的提高用户对于数据库的管理效率，更加的灵活的满足不同的用户的需求。</p>
          </div><div class="tabs" id="tags"><ul class="nav-tabs"><li class="tab active"><a href="#tags-1">数学函数</a></li><li class="tab"><a href="#tags-2">字符串函数</a></li><li class="tab"><a href="#tags-3">日期和时间函数</a></li></ul><div class="tab-content"><div class="tab-pane active" id="tags-1"><div class="note success">
            <h4 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abs（x） 返回x的绝对值。</span><br><span class="line">pi（x） 返回圆周率n，默认显示6为小数。</span><br><span class="line">sqrt（x） 返回非负数x的二次方根</span><br><span class="line">mod（x，y） 返回x被y除后的余数</span><br><span class="line">ceil（x），ceiling（x） 返回不小于x的最小整数</span><br><span class="line">floor（x） 返回不大于x的最大整数</span><br><span class="line">round（x），round（x，y） 前者返回最近于x的整数（四舍五入）；后者返回最接近于x的数，其值保留到小数点后面y位，若y为负值，则将保留到x到小数点左边y位</span><br><span class="line">sign（x） 返回参数x的符号，-1表示负数，0表示0，1表示正数</span><br><span class="line">pow（x，y），power（x，y） 返回x的y次乘方的值</span><br><span class="line">exp（x） e的x次乘方的值</span><br><span class="line">log（x） x相对于基数e的对数</span><br><span class="line">log10（x） 返回x的基数10的对数</span><br><span class="line">radians（x） x由角度转化为弧度的值</span><br><span class="line">degrees（x） x由弧度转化为角度的值</span><br><span class="line">sin（x），asin（x） 前者返回x的正弦，其中x为给定的弧度值；后者返回x的反正弦值，x为正弦</span><br><span class="line">cos（x），acos（x） 前者返回x的余弦，其中x为给定的弧度值；后者返回x的反余弦值，x为余弦</span><br><span class="line">tan（x），atan（x） 前者返回x的正切，其中x为给定的弧度值；后者返回x的反正切值，x为正切</span><br><span class="line">cot（x） 返回给定弧度值x的余切</span><br></pre></td></tr></table></figure>
          </div></div><div class="tab-pane" id="tags-2"><div class="note success">
            <h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char_length（str）  计算字符串字符个数</span><br><span class="line">concat（s1，s2，...）  返回连接参数产生的字符串，一个或多个待拼接的内容，任意一个为NULL则返回值为NULL、</span><br><span class="line">concat_ws(x,s1,s2,...)   返回多个字符串拼接之后的字符串，每个字符串之间有一个x</span><br><span class="line">insert(s1,x,len,s2)  返回字符串s1，其子字符串起始于位置x，被字符串s2取代len个字符</span><br><span class="line">lower(str)和lcast(str);upper(str)和ucast(str) 前两者将str中的字母全部转换成小写，后两者将字符串中的字母全部转换成大写</span><br><span class="line">left(s,n),right(s,n)  前者返回字符串s从最左边开始的n个字符，后者返回字符串s从最右边开始的n个字符</span><br><span class="line">lpad(s1,len,s2),rpad(s1,len,s2)  前者返回s1，其左边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符；前者返回s1，其右边由字符串s2填补到len字符长度，假如s1的长度大于len，则返回值被缩短至len字符</span><br><span class="line">ltrim(s),rtrim(s)  前者返回字符串s，其左边所有空格被删除；后者返回字符串s，其右边所有空格被删除</span><br><span class="line">trim(s)  返回字符串s删除了两边空格之后的字符串</span><br><span class="line">trim(s1 from s)  删除字符串s两端所有子字符串s1，未指定s1的情况下则默认删除空格</span><br><span class="line">repeat(s,n)  返回一个由重复字符串s组成的字符串，字符串s的数目等于n</span><br><span class="line">space(n)  返回一个由n个空格组成的字符串</span><br><span class="line">replace(s,s1,s2)  返回一个字符串，用字符串s2替代字符串s中所有的字符串s1</span><br><span class="line">strcmp(s1,s2)  若s1和s2中所有的字符串都相同，则返回0；根据当前分类次序，第一个参数小于第二个则返回-1，其他情况返回1</span><br><span class="line">substring(s,n,len),mid(s,n,len)  两个函数作用相同，从字符串s中返回一个第n个字符开始、长度为len的字符串</span><br><span class="line">locate(str1,str),position(str1 in str),instr(str,str1)  三个函数作用相同，返回子字符串str1在字符串str中的开始位置（从第几个字符开始）</span><br><span class="line">reverst(s)  将字符串s反转</span><br><span class="line">elt(n,str1,str2,str3,...)  返回第N个字符串 </span><br></pre></td></tr></table></figure>
          </div></div><div class="tab-pane" id="tags-3"><div class="note success">
            <h4 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curdate(),current_date()  将当前日期按照&quot;YYYY-MM-DD&quot;或者&quot;YYYYMMDD&quot;格式的值返回，具体格式根据函数用在字符串或是数字语境中而定</span><br><span class="line">CURRENT_TIMESTAMP()、LOCALTIME()、NOW()、SYSDATE()   这四个函数作用相同，返回当前日期和时间值，格式为&quot;YYYY_MM-DD HH:MM:SS&quot;或&quot;YYYYMMDDHHMMSS&quot;，具体格式根据函数用在字符串或数字语境中而定</span><br><span class="line">UNIX_TIMESTAMP()、UNIX_TIMESTAMP(date)  前者返回一个格林尼治标准时间1970-01-01 00:00:00到现在的秒数，后者返回一个格林尼治标准时间1970-01-01 00:00:00到指定时间的秒数</span><br><span class="line">FROM_UNIXTIME(date)  和UNIX_TIMESTAMP互为反函数，把UNIX时间戳转换为普通格式的时间</span><br><span class="line">UTC_DATE()和UTC_TIME()  前者返回当前UTC（世界标准时间）日期值，其格式为&quot;YYYY-MM-DD&quot;或&quot;YYYYMMDD&quot;，后者返回当前UTC时间值，其格式为&quot;YYYY-MM-DD&quot;或&quot;YYYYMMDD&quot;。具体使用哪种取决于函数用在字符串还是数字语境中</span><br></pre></td></tr></table></figure>
          </div></div></div></div><a id="more"></a>



<p>欢迎大家评论呦！</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
